import { fmtFileSize, trimPath, fileExt, isStr } from './utils.ts';
const encoder = new TextEncoder();
export async function findFile({ path, collect, exclude, ignore, hasInfo, isFirst }) {
    let rs;
    try {
        rs = Deno.readDirSync(path);
    }
    catch (e) {
        await Deno.stderr.write(encoder.encode('NotFound: No such file or directory\n'));
        Deno.exit(-1);
    }
    path = trimPath(path);
    if (exclude && exclude.length) {
        let flag = false;
        exclude.some(i => {
            if (trimPath(i) === path) {
                flag = true;
                return true;
            }
        });
        if (flag)
            return;
    }
    for (const item of rs) {
        let _path = `${path}/${item.name}`;
        _path = trimPath(_path);
        if (item.isDirectory) {
            findFile({ path: _path, collect, exclude, ignore, hasInfo, isFirst: false });
        }
        else {
            const fExt = fileExt(item.name);
            let flag = false;
            if (ignore && ignore.length) {
                ignore.some(i => {
                    const regRule = (/^\*\./.test(i) && isFirst) || /\*\*\/\*\./.test(i);
                    if ((regRule && fExt && fExt === fileExt(i)) || trimPath(i) === _path) {
                        flag = true;
                        return true;
                    }
                });
            }
            let fileInfo = null;
            if (hasInfo) {
                const info = Deno.statSync(_path);
                fileInfo = {
                    ...info,
                    fmtSize: fmtFileSize(info.size),
                };
            }
            !flag && collect.push({
                path: _path,
                name: item.name,
                ext: fExt,
                realPath: Deno.realPathSync(_path),
                info: fileInfo,
            });
        }
    }
}
export function getFiles(opts) {
    const files = [];
    if (isStr(opts)) {
        findFile({ path: opts, collect: files });
    }
    else {
        const { root, include, exclude, ignore, hasInfo } = opts;
        if (root && include === undefined) {
            findFile({ path: root, collect: files, exclude, ignore, hasInfo, isFirst: true });
        }
        if (include && include.length === 0)
            return [];
        if (include) {
            include.forEach(dir => findFile({ path: dir, collect: files, ignore, exclude, hasInfo, isFirst: true }));
        }
    }
    return files;
}
export default getFiles;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFLQSxPQUFPLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBR25FLE1BQU0sT0FBTyxHQUFHLElBQUksV0FBVyxFQUFFLENBQUM7QUFFbEMsTUFBTSxDQUFDLEtBQUssVUFBVSxRQUFRLENBQUMsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBbUI7SUFDbEcsSUFBSSxFQUFFLENBQUM7SUFDUCxJQUFJO1FBQ0YsRUFBRSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDN0I7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDLENBQUE7UUFDaEYsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2Y7SUFFRCxJQUFJLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXRCLElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7UUFDN0IsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDO1FBQ2pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDZixJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUU7Z0JBQ3hCLElBQUksR0FBRyxJQUFJLENBQUM7Z0JBQ1osT0FBTyxJQUFJLENBQUM7YUFDYjtRQUNILENBQUMsQ0FBQyxDQUFBO1FBQ0YsSUFBSSxJQUFJO1lBQUUsT0FBTztLQUNsQjtJQUVELEtBQUssTUFBTSxJQUFJLElBQUksRUFBRSxFQUFFO1FBQ3JCLElBQUksS0FBSyxHQUFHLEdB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QUE7U0FDekc7S0FDRjtJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUVELGVBQWUsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAYXV0aG9yOiBsZW5jeFxuICogQGNyZWF0ZV9hdDogSnVuIDE3LCAyMDIwXG4gKi9cblxuaW1wb3J0IHsgZm10RmlsZVNpemUsIHRyaW1QYXRoLCBmaWxlRXh0LCBpc1N0ciB9IGZyb20gJy4vdXRpbHMudHMnO1xuaW1wb3J0IHsgR2V0RmlsZXNPcHRpb25zLCBGaW5kRmlsZU9wdGlvbnMsIEZpbGVJbmZvIH0gZnJvbSAnLi90eXBlcy50cyc7XG5cbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpbmRGaWxlKHsgcGF0aCwgY29sbGVjdCwgZXhjbHVkZSwgaWdub3JlLCBoYXNJbmZvLCBpc0ZpcnN0IH06IEZpbmRGaWxlT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICBsZXQgcnM7XG4gIHRyeSB7XG4gICAgcnMgPSBEZW5vLnJlYWREaXJTeW5jKHBhdGgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgYXdhaXQgRGVuby5zdGRlcnIud3JpdGUoZW5jb2Rlci5lbmNvZGUoJ05vdEZvdW5kOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XFxuJykpXG4gICAgRGVuby5leGl0KC0xKTtcbiAgfVxuXG4gIHBhdGggPSB0cmltUGF0aChwYXRoKTtcblxuICBpZiAoZXhjbHVkZSAmJiBleGNsdWRlLmxlbmd0aCkge1xuICAgIGxldCBmbGFnID0gZmFsc2U7XG4gICAgZXhjbHVkZS5zb21lKGkgPT4ge1xuICAgICAgaWYgKHRyaW1QYXRoKGkpID09PSBwYXRoKSB7XG4gICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChmbGFnKSByZXR1cm47XG4gIH1cblxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgcnMpIHtcbiAgICBsZXQgX3BhdGggPSBgJHtwYXRofS8ke2l0ZW0ubmFtZX1gO1xuICAgIF9wYXRoID0gdHJpbVBhdGgoX3BhdGgpO1xuICAgIGlmIChpdGVtLmlzRGlyZWN0b3J5KSB7XG4gICAgICAvLyByZWN1cnNpdmVseSBkaXJlY3RvcnlcbiAgICAgIGZpbmRGaWxlKHsgcGF0aDogX3BhdGgsIGNvbGxlY3QsIGV4Y2x1ZGUsIGlnbm9yZSwgaGFzSW5mbywgaXNGaXJzdDogZmFsc2UgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZFeHQgPSBmaWxlRXh0KGl0ZW0ubmFtZSk7XG5cbiAgICAgIC8vPT09IGlnbm9yZSBydWxlc1xuICAgICAgLy8gYCoqLyoudHNgOiByZWN1cnNpdmUgZGlyZWN0b3J5IGlnbm9yZXMgZmlsZXNcbiAgICAgIC8vIGAqLnRzYCA6IGlnbm9yZSBmaWxlcyB1bmRlciBgcm9vdCBwYXRoYCBvciBgaW5jbHVkZSBwYXRoYFxuICAgICAgLy8gYGEvYi9jLnRzYDogc3BlY2lmaWMgaWdub3JlIGZpbGVzXG4gICAgICBsZXQgZmxhZyA9IGZhbHNlO1xuICAgICAgaWYgKGlnbm9yZSAmJiBpZ25vcmUubGVuZ3RoKSB7XG4gICAgICAgIGlnbm9yZS5zb21lKGkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlZ1J1bGUgPSAoL15cXCpcXC4vLnRlc3QoaSkgJiYgaXNGaXJzdCkgfHwgL1xcKlxcKlxcL1xcKlxcLi8udGVzdChpKTtcbiAgICAgICAgICBpZiAoKHJlZ1J1bGUgJiYgZkV4dCAmJiBmRXh0ID09PSBmaWxlRXh0KGkpKSB8fCB0cmltUGF0aChpKSA9PT0gX3BhdGgpIHtcbiAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBjb2xsZWN0IGZpbGVzIGFjY29yZGluZyB0byBydWxlc1xuICAgICAgbGV0IGZpbGVJbmZvID0gbnVsbDtcbiAgICAgIGlmIChoYXNJbmZvKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBEZW5vLnN0YXRTeW5jKF9wYXRoKTtcbiAgICAgICAgZmlsZUluZm8gPSB7XG4gICAgICAgICAgLi4uaW5mbyxcbiAgICAgICAgICBmbXRTaXplOiBmbXRGaWxlU2l6ZShpbmZvLnNpemUpLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAhZmxhZyAmJiBjb2xsZWN0LnB1c2goe1xuICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgbmFtZTogaXRlbS5uYW1lLFxuICAgICAgICBleHQ6IGZFeHQsXG4gICAgICAgIHJlYWxQYXRoOiBEZW5vLnJlYWxQYXRoU3luYyhfcGF0aCksXG4gICAgICAgIGluZm86IGZpbGVJbmZvLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlczxUIGV4dGVuZHMgKHN0cmluZyB8IEdldEZpbGVzT3B0aW9ucyk+KG9wdHM6IFQpOiBGaWxlSW5mb1tdIHtcbiAgY29uc3QgZmlsZXM6IEZpbGVJbmZvW10gPSBbXTtcblxuICBpZiAoaXNTdHIob3B0cykpIHtcbiAgICBmaW5kRmlsZSh7IHBhdGg6IChvcHRzIGFzIHN0cmluZyksIGNvbGxlY3Q6IGZpbGVzIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZXJlIGFyZSBtdWx0aXBsZSBwYXJhbWV0ZXJzXG4gICAgY29uc3QgeyByb290LCBpbmNsdWRlLCBleGNsdWRlLCBpZ25vcmUsIGhhc0luZm8gfSA9IChvcHRzIGFzIEdldEZpbGVzT3B0aW9ucyk7XG5cbiAgICBpZiAocm9vdCAmJiBpbmNsdWRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmRGaWxlKHsgcGF0aDogcm9vdCwgY29sbGVjdDogZmlsZXMsIGV4Y2x1ZGUsIGlnbm9yZSwgaGFzSW5mbywgaXNGaXJzdDogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZSAmJiBpbmNsdWRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuXG4gICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgIGluY2x1ZGUuZm9yRWFjaChkaXIgPT4gZmluZEZpbGUoeyBwYXRoOiBkaXIsIGNvbGxlY3Q6IGZpbGVzLCBpZ25vcmUsIGV4Y2x1ZGUsIGhhc0luZm8sIGlzRmlyc3Q6IHRydWUgfSkpXG4gICAgfVxuICB9XG4gIHJldHVybiBmaWxlcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0RmlsZXM7Il19