import { SAXParser } from "../deps.ts";
import { FeedParseType, FeedType } from "./types/mod.ts";
import { isAtomCDataField, resolveAtomField, resolveRss1Field, resolveRss2Field, } from "./resolvers/mod.ts";
import { toFeed, toJsonFeed, toLegacyAtom, toLegacyRss1, toLegacyRss2, } from "./mappers/mod.ts";
export async function parseFeed(input) {
    if (!input) {
        throw new Error("Input was undefined, null or empty");
    }
    const { data, feedType } = await parse(input);
    return toFeed(feedType, data);
}
export const deserializeFeed = (async (input, options) => {
    const { data, feedType } = await parse(input);
    let legacyFeed;
    switch (feedType) {
        case FeedType.Rss1:
            legacyFeed = toLegacyRss1(data);
            break;
        case FeedType.Rss2:
            legacyFeed = toLegacyRss2(data);
            break;
        case FeedType.Atom:
            legacyFeed = toLegacyAtom(data);
            break;
        default:
            legacyFeed = data;
            break;
    }
    const result = {
        feed: options?.outputJsonFeed
            ? toJsonFeed(feedType, legacyFeed)
            : legacyFeed,
        feedType: options?.outputJsonFeed ? FeedType.JsonFeed : feedType,
        originalFeedType: feedType,
    };
    return result;
});
const parse = (input) => new Promise((resolve, reject) => {
    if (!input) {
        reject(new Error("Input was undefined, null or empty"));
        return;
    }
    input = input
        .replaceAll(/<description>(?!(\s*<!\[CDATA))/g, `<description><![CDATA[`)
        .replaceAll(/(?<!\]\]>\s*)<\/description>/g, `]]></description>`);
    let cDataLevel;
    let cDataBuilder;
    let cDataActive;
    let feedType;
    let currentTag;
    const stack = [{}];
    const parser = new SAXParser(false, {
        trim: true,
        lowercase: true,
    });
    let resolveField;
    let isCDataField;
    parser.oncdata = parser.ontext = (text) => {
        if (cDataActive) {
            cDataBuilder += text;
        }
        else {
            stack[stack.length - 1].value = text.trim();
        }
    };
    const onOpenTag = (node) => {
        currentTag = node;
        const attributeNames = Object.keys(node.attributes);
        if (cDataActive) {
            const attributes = attributeNames
                .map((key) => `${key}="${node.attributes[key]}"`)
                .join(" ")
                .trim();
            if (attributes.length) {
                cDataBuilder += `<${node.name} ${attributes}${(node.isSelfClosing
                    ? " /"
                    : "")}>`;
            }
            else {
                cDataBuilder += `<${node.name}${(node.isSelfClosing ? " /" : "")}>`;
            }
            cDataLevel++;
            return;
        }
        if (isCDataField(node.name)) {
            cDataActive = true;
            cDataBuilder = "";
            cDataLevel = 0;
        }
        const newNode = attributeNames.reduce((builder, attrName) => {
            const val = node.attributes[attrName];
            if (val !== undefined && val !== null) {
                const { name, isInt, isFloat, isDate } = resolveField(attrName);
                if (isInt) {
                    builder[name] = parseInt(val);
                }
                else if (isFloat) {
                    builder[name] = parseFloat(val);
                }
                else if (isDate) {
                    builder[name + "Raw"] = val;
                    builder[name] = new Date(val);
                }
                else {
                    builder[name] = val;
                }
            }
            return builder;
        }, {});
        stack.push(newNode);
    };
    parser.onclosetag = (nodeName) => {
        const currentStartTag = currentTag;
        currentTag = undefined;
        if (cDataActive && cDataLevel) {
            if (!currentStartTag?.isSelfClosing) {
                cDataBuilder += `</${nodeName}>`;
            }
            cDataLevel--;
            return;
        }
        let node = stack.pop();
        if (stack.length === 0) {
            Object.assign(parser, {
                onopentag: undefined,
                onclosetag: undefined,
                ontext: undefined,
                oncdata: undefined,
            });
            const result = {
                feedType: feedType,
                data: node,
            };
            resolve(result);
            return;
        }
        const targetNode = stack[stack.length - 1];
        const { name, isArray, isInt, isFloat, isDate, } = resolveField(nodeName);
        if (cDataActive) {
            node.value = cDataBuilder;
            targetNode[name] = node;
            cDataBuilder = "";
            cDataActive = false;
            cDataLevel = 0;
            return;
        }
        if (node.value !== undefined && node.value !== null) {
            if (isInt) {
                node.value = parseInt(node.value);
            }
            else if (isFloat) {
                node.value = parseFloat(node.value);
            }
            else if (isDate) {
                targetNode[name + "Raw"] = { value: node.value };
                node.value = new Date(node.value);
            }
        }
        if (isArray) {
            if (!targetNode[name]) {
                targetNode[name] = [node];
            }
            else {
                targetNode[name].push(node);
            }
        }
        else {
            const isEmpty = (typeof node === "object") &&
                Object.keys(node).length === 0 &&
                !(node instanceof Date);
            try {
                if (!isEmpty) {
                    targetNode[name] = node;
                }
            }
            catch {
                console.warn(`Failed to add property ${name} on node`, targetNode);
            }
        }
    };
    parser.onopentag = (node) => {
        switch (node.name) {
            case FeedParseType.Atom:
                feedType = FeedType.Atom;
                isCDataField = isAtomCDataField;
                resolveField = resolveAtomField;
                break;
            case FeedParseType.Rss2:
                feedType = FeedType.Rss2;
                isCDataField = () => false;
                resolveField = resolveRss2Field;
                break;
            case FeedParseType.Rss1:
                feedType = FeedType.Rss1;
                isCDataField = () => false;
                resolveField = resolveRss1Field;
                break;
            default:
                reject(new Error(`Type ${node.name} is not supported`));
                break;
        }
        parser.onopentag = onOpenTag;
    };
    parser
        .write(input)
        .close()
        .flush();
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVzZXJpYWxpemVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiaHR0cHM6Ly9kZW5vLmxhbmQveC9yc3NAMC41LjUvc3JjL2Rlc2VyaWFsaXplci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBVXZDLE9BQU8sRUFBRSxhQUFhLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDekQsT0FBTyxFQUNMLGdCQUFnQixFQUNoQixnQkFBZ0IsRUFDaEIsZ0JBQWdCLEVBQ2hCLGdCQUFnQixHQUNqQixNQUFNLG9CQUFvQixDQUFDO0FBQzVCLE9BQU8sRUFDTCxNQUFNLEVBQ04sVUFBVSxFQUNWLFlBQVksRUFDWixZQUFZLEVBQ1osWUFBWSxHQUNiLE1BQU0sa0JBQWtCLENBQUM7QUFNMUIsTUFBTSxDQUFDLEtBQUssVUFBVSxTQUFTLENBQUMsS0FBYTtJQUMzQyxJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO0tBQ3ZEO0lBRUQsTUFBTSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsR0FBRyxNQUFNLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM5QyxPQUFPLE1BQU0sQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFFLENBQUM7QUFDakMsQ0FBQztBQVNELE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxDQUFDLEtBQUssRUFDbkMsS0FBYSxFQUNiLE9BQWlCLEVBQ2pCLEVBQUU7SUFDRixNQUFNLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxHQUFHLE1BQU0sS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzlDLElBQUksVUFBVSxDQUFDO0lBQ2YsUUFBUSxRQUFRLEVBQUU7UUFDaEIsS0FBSyxRQUFRLENBQUMsSUFBSTtZQUNoQixVQUFVLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBUSxDQUFDO1lBQ3ZD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QUFDO1NBQ1osS0FBSyxFQUFFO1NBQ1AsS0FBSyxFQUFFLENBQUM7QUFDYixDQUFDLENBQ0YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNBWFBhcnNlciB9IGZyb20gXCIuLi9kZXBzLnRzXCI7XG5pbXBvcnQgdHlwZSB7XG4gIEF0b20sXG4gIERlc2VyaWFsaXphdGlvblJlc3VsdCxcbiAgRmVlZCxcbiAgSnNvbkZlZWQsXG4gIFJTUzEsXG4gIFJTUzIsXG59IGZyb20gXCIuL3R5cGVzL21vZC50c1wiO1xuaW1wb3J0IHR5cGUgeyBSZXNvbHZlclJlc3VsdCB9IGZyb20gXCIuL3Jlc29sdmVycy90eXBlcy9yZXNvbHZlcl9yZXN1bHQudHNcIjtcbmltcG9ydCB7IEZlZWRQYXJzZVR5cGUsIEZlZWRUeXBlIH0gZnJvbSBcIi4vdHlwZXMvbW9kLnRzXCI7XG5pbXBvcnQge1xuICBpc0F0b21DRGF0YUZpZWxkLFxuICByZXNvbHZlQXRvbUZpZWxkLFxuICByZXNvbHZlUnNzMUZpZWxkLFxuICByZXNvbHZlUnNzMkZpZWxkLFxufSBmcm9tIFwiLi9yZXNvbHZlcnMvbW9kLnRzXCI7XG5pbXBvcnQge1xuICB0b0ZlZWQsXG4gIHRvSnNvbkZlZWQsXG4gIHRvTGVnYWN5QXRvbSxcbiAgdG9MZWdhY3lSc3MxLFxuICB0b0xlZ2FjeVJzczIsXG59IGZyb20gXCIuL21hcHBlcnMvbW9kLnRzXCI7XG5cbi8qKlxuICogUGFyc2UgQXRvbSBvciBSU1MgaW50byBhIGNvbW1vbiBGZWVkIHR5cGVcbiAqIEBwYXJhbSBBdG9tIG9yIFJTUyBYTUwgc3RyaW5nXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZUZlZWQoaW5wdXQ6IHN0cmluZyk6IFByb21pc2U8RmVlZD4ge1xuICBpZiAoIWlucHV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgd2FzIHVuZGVmaW5lZCwgbnVsbCBvciBlbXB0eVwiKTtcbiAgfVxuXG4gIGNvbnN0IHsgZGF0YSwgZmVlZFR5cGUgfSA9IGF3YWl0IHBhcnNlKGlucHV0KTtcbiAgcmV0dXJuIHRvRmVlZChmZWVkVHlwZSwgZGF0YSkhO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnMge1xuICBvdXRwdXRKc29uRmVlZD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhlIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQsIHBsZWFzZSB1c2UgdGhlIHBhcnNlRmVlZCBtZXRob2QgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRlc2VyaWFsaXplRmVlZCA9IChhc3luYyAoXG4gIGlucHV0OiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBPcHRpb25zLFxuKSA9PiB7XG4gIGNvbnN0IHsgZGF0YSwgZmVlZFR5cGUgfSA9IGF3YWl0IHBhcnNlKGlucHV0KTtcbiAgbGV0IGxlZ2FjeUZlZWQ7XG4gIHN3aXRjaCAoZmVlZFR5cGUpIHtcbiAgICBjYXNlIEZlZWRUeXBlLlJzczE6XG4gICAgICBsZWdhY3lGZWVkID0gdG9MZWdhY3lSc3MxKGRhdGEpIGFzIGFueTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRmVlZFR5cGUuUnNzMjpcbiAgICAgIGxlZ2FjeUZlZWQgPSB0b0xlZ2FjeVJzczIoZGF0YSkgYXMgYW55O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGZWVkVHlwZS5BdG9tOlxuICAgICAgbGVnYWN5RmVlZCA9IHRvTGVnYWN5QXRvbShkYXRhKSBhcyBhbnk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbGVnYWN5RmVlZCA9IGRhdGE7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdDogRGVzZXJpYWxpemF0aW9uUmVzdWx0PEF0b20gfCBSU1MxIHwgUlNTMiB8IEpzb25GZWVkPiAmIHtcbiAgICBvcmlnaW5hbEZlZWRUeXBlPzogRmVlZFR5cGU7XG4gIH0gPSB7XG4gICAgZmVlZDogb3B0aW9ucz8ub3V0cHV0SnNvbkZlZWRcbiAgICAgID8gdG9Kc29uRmVlZChmZWVkVHlwZSwgbGVnYWN5RmVlZClcbiAgICAgIDogbGVnYWN5RmVlZCxcbiAgICBmZWVkVHlwZTogb3B0aW9ucz8ub3V0cHV0SnNvbkZlZWQgPyBGZWVkVHlwZS5Kc29uRmVlZCA6IGZlZWRUeXBlLFxuICAgIG9yaWdpbmFsRmVlZFR5cGU6IGZlZWRUeXBlLFxuICB9O1xuXG4gIHJldHVybiByZXN1bHQ7XG59KSBhcyB7XG4gIChpbnB1dDogc3RyaW5nKTogUHJvbWlzZTxEZXNlcmlhbGl6YXRpb25SZXN1bHQ8QXRvbSB8IFJTUzEgfCBSU1MyPj47XG4gIChcbiAgICBpbnB1dDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IE9wdGlvbnMgJiB7IG91dHB1dEpzb25GZWVkOiBmYWxzZSB9LFxuICApOiBQcm9taXNlPERlc2VyaWFsaXphdGlvblJlc3VsdDxBdG9tIHwgUlNTMSB8IFJTUzI+PjtcbiAgKFxuICAgIGlucHV0OiBzdHJpbmcsXG4gICAgb3B0aW9uczogT3B0aW9ucyAmIHsgb3V0cHV0SnNvbkZlZWQ6IHRydWUgfSxcbiAgKTogUHJvbWlzZTxcbiAgICBEZXNlcmlhbGl6YXRpb25SZXN1bHQ8SnNvbkZlZWQ+ICYgeyBvcmlnaW5hbEZlZWRUeXBlOiBGZWVkVHlwZSB9XG4gID47XG4gIChcbiAgICBpbnB1dDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBPcHRpb25zLFxuICApOiBQcm9taXNlPERlc2VyaWFsaXphdGlvblJlc3VsdDxBdG9tIHwgSnNvbkZlZWQgfCBSU1MxIHwgUlNTMj4+O1xufTtcblxuY29uc3QgcGFyc2UgPSAoaW5wdXQ6IHN0cmluZykgPT5cbiAgbmV3IFByb21pc2U8eyBmZWVkVHlwZTogRmVlZFR5cGU7IGRhdGE6IGFueSB9PihcbiAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJJbnB1dCB3YXMgdW5kZWZpbmVkLCBudWxsIG9yIGVtcHR5XCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvL1x0SGFuZGxlIGludmFsaWQgZmVlZCBkb2N1bWVudHMgYnkgY29udmVydGluZyB0aGUgZGVzY3JpcHRpb24gZmllbGQgdG8gQ0RBVEEuXG4gICAgICBpbnB1dCA9IGlucHV0XG4gICAgICAgIC5yZXBsYWNlQWxsKFxuICAgICAgICAgIC88ZGVzY3JpcHRpb24+KD8hKFxccyo8IVxcW0NEQVRBKSkvZyxcbiAgICAgICAgICBgPGRlc2NyaXB0aW9uPjwhW0NEQVRBW2AsXG4gICAgICAgIClcbiAgICAgICAgLnJlcGxhY2VBbGwoLyg/PCFcXF1cXF0+XFxzKik8XFwvZGVzY3JpcHRpb24+L2csIGBdXT48L2Rlc2NyaXB0aW9uPmApO1xuXG4gICAgICBsZXQgY0RhdGFMZXZlbDogbnVtYmVyO1xuICAgICAgbGV0IGNEYXRhQnVpbGRlcjogc3RyaW5nO1xuICAgICAgbGV0IGNEYXRhQWN0aXZlOiBib29sZWFuO1xuICAgICAgbGV0IGZlZWRUeXBlOiBGZWVkVHlwZTtcblxuICAgICAgbGV0IGN1cnJlbnRUYWc6IE9wZW5UYWcgfCB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBzdGFjazogYW55W10gPSBbe31dO1xuICAgICAgY29uc3QgcGFyc2VyID0gbmV3IFNBWFBhcnNlcihmYWxzZSwge1xuICAgICAgICB0cmltOiB0cnVlLFxuICAgICAgICBsb3dlcmNhc2U6IHRydWUsXG4gICAgICB9KTtcblxuICAgICAgbGV0IHJlc29sdmVGaWVsZDogKFxuICAgICAgICBub2RlTmFtZTogc3RyaW5nLFxuICAgICAgKSA9PiBSZXNvbHZlclJlc3VsdDtcblxuICAgICAgbGV0IGlzQ0RhdGFGaWVsZDogKG5vZGVOYW1lOiBzdHJpbmcpID0+IGJvb2xlYW47XG5cbiAgICAgIHBhcnNlci5vbmNkYXRhID0gcGFyc2VyLm9udGV4dCA9ICh0ZXh0OiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKGNEYXRhQWN0aXZlKSB7XG4gICAgICAgICAgY0RhdGFCdWlsZGVyICs9IHRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0udmFsdWUgPSB0ZXh0LnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgb25PcGVuVGFnID0gKG5vZGU6IE9wZW5UYWcpOiB2b2lkID0+IHtcbiAgICAgICAgY3VycmVudFRhZyA9IG5vZGU7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMobm9kZS5hdHRyaWJ1dGVzKTtcblxuICAgICAgICBpZiAoY0RhdGFBY3RpdmUpIHtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gYXR0cmlidXRlTmFtZXNcbiAgICAgICAgICAgIC5tYXAoKGtleSkgPT4gYCR7a2V5fT1cIiR7KG5vZGUuYXR0cmlidXRlcyBhcyBhbnkpW2tleV19XCJgKVxuICAgICAgICAgICAgLmpvaW4oXCIgXCIpXG4gICAgICAgICAgICAudHJpbSgpO1xuXG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjRGF0YUJ1aWxkZXIgKz0gYDwke25vZGUubmFtZX0gJHthdHRyaWJ1dGVzfSR7KG5vZGUuaXNTZWxmQ2xvc2luZ1xuICAgICAgICAgICAgICA/IFwiIC9cIlxuICAgICAgICAgICAgICA6IFwiXCIpfT5gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjRGF0YUJ1aWxkZXIgKz0gYDwke25vZGUubmFtZX0keyhub2RlLmlzU2VsZkNsb3NpbmcgPyBcIiAvXCIgOiBcIlwiKX0+YDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjRGF0YUxldmVsKys7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ0RhdGFGaWVsZChub2RlLm5hbWUpKSB7XG4gICAgICAgICAgY0RhdGFBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgIGNEYXRhQnVpbGRlciA9IFwiXCI7XG4gICAgICAgICAgY0RhdGFMZXZlbCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdOb2RlID0gYXR0cmlidXRlTmFtZXMucmVkdWNlKChidWlsZGVyLCBhdHRyTmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IChub2RlLmF0dHJpYnV0ZXMgYXMgYW55KVthdHRyTmFtZV07XG4gICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBpc0ludCwgaXNGbG9hdCwgaXNEYXRlIH0gPSByZXNvbHZlRmllbGQoYXR0ck5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaXNJbnQpIHtcbiAgICAgICAgICAgICAgYnVpbGRlcltuYW1lXSA9IHBhcnNlSW50KHZhbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRmxvYXQpIHtcbiAgICAgICAgICAgICAgYnVpbGRlcltuYW1lXSA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKSB7XG4gICAgICAgICAgICAgIGJ1aWxkZXJbbmFtZSArIFwiUmF3XCJdID0gdmFsO1xuICAgICAgICAgICAgICBidWlsZGVyW25hbWVdID0gbmV3IERhdGUodmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJ1aWxkZXJbbmFtZV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgICAgIH0sIHt9IGFzIGFueSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChuZXdOb2RlKTtcbiAgICAgIH07XG5cbiAgICAgIHBhcnNlci5vbmNsb3NldGFnID0gKG5vZGVOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXJ0VGFnID0gY3VycmVudFRhZztcbiAgICAgICAgY3VycmVudFRhZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNEYXRhQWN0aXZlICYmIGNEYXRhTGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWN1cnJlbnRTdGFydFRhZz8uaXNTZWxmQ2xvc2luZykge1xuICAgICAgICAgICAgY0RhdGFCdWlsZGVyICs9IGA8LyR7bm9kZU5hbWV9PmA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY0RhdGFMZXZlbC0tO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBub2RlID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VyLCB7XG4gICAgICAgICAgICBvbm9wZW50YWc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uY2xvc2V0YWc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9udGV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb25jZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZmVlZFR5cGU6IGZlZWRUeXBlLFxuICAgICAgICAgICAgZGF0YTogbm9kZSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaXNBcnJheSxcbiAgICAgICAgICBpc0ludCxcbiAgICAgICAgICBpc0Zsb2F0LFxuICAgICAgICAgIGlzRGF0ZSxcbiAgICAgICAgfSA9IHJlc29sdmVGaWVsZChub2RlTmFtZSk7XG5cbiAgICAgICAgaWYgKGNEYXRhQWN0aXZlKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9IGNEYXRhQnVpbGRlcjtcbiAgICAgICAgICB0YXJnZXROb2RlW25hbWVdID0gbm9kZTtcbiAgICAgICAgICBjRGF0YUJ1aWxkZXIgPSBcIlwiO1xuICAgICAgICAgIGNEYXRhQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgY0RhdGFMZXZlbCA9IDA7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBub2RlLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlzSW50KSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gcGFyc2VJbnQobm9kZS52YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0Zsb2F0KSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gcGFyc2VGbG9hdChub2RlLnZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZSkge1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZVtuYW1lICsgXCJSYXdcIl0gPSB7IHZhbHVlOiBub2RlLnZhbHVlIH07XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gbmV3IERhdGUobm9kZS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICBpZiAoIXRhcmdldE5vZGVbbmFtZV0pIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGVbbmFtZV0gPSBbbm9kZV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGVbbmFtZV0ucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaXNFbXB0eSA9ICh0eXBlb2Ygbm9kZSA9PT0gXCJvYmplY3RcIikgJiZcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG5vZGUpLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgIShub2RlIGluc3RhbmNlb2YgRGF0ZSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgICB0YXJnZXROb2RlW25hbWVdID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgYEZhaWxlZCB0byBhZGQgcHJvcGVydHkgJHtuYW1lfSBvbiBub2RlYCxcbiAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBwYXJzZXIub25vcGVudGFnID0gKG5vZGU6IE9wZW5UYWcpID0+IHtcbiAgICAgICAgc3dpdGNoIChub2RlLm5hbWUpIHtcbiAgICAgICAgICBjYXNlIEZlZWRQYXJzZVR5cGUuQXRvbTpcbiAgICAgICAgICAgIGZlZWRUeXBlID0gRmVlZFR5cGUuQXRvbTtcbiAgICAgICAgICAgIGlzQ0RhdGFGaWVsZCA9IGlzQXRvbUNEYXRhRmllbGQ7XG4gICAgICAgICAgICByZXNvbHZlRmllbGQgPSByZXNvbHZlQXRvbUZpZWxkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBGZWVkUGFyc2VUeXBlLlJzczI6XG4gICAgICAgICAgICBmZWVkVHlwZSA9IEZlZWRUeXBlLlJzczI7XG4gICAgICAgICAgICBpc0NEYXRhRmllbGQgPSAoKSA9PiBmYWxzZTtcbiAgICAgICAgICAgIHJlc29sdmVGaWVsZCA9IHJlc29sdmVSc3MyRmllbGQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEZlZWRQYXJzZVR5cGUuUnNzMTpcbiAgICAgICAgICAgIGZlZWRUeXBlID0gRmVlZFR5cGUuUnNzMTtcbiAgICAgICAgICAgIGlzQ0RhdGFGaWVsZCA9ICgpID0+IGZhbHNlO1xuICAgICAgICAgICAgcmVzb2x2ZUZpZWxkID0gcmVzb2x2ZVJzczFGaWVsZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBUeXBlICR7bm9kZS5uYW1lfSBpcyBub3Qgc3VwcG9ydGVkYCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLm9ub3BlbnRhZyA9IG9uT3BlblRhZztcbiAgICAgIH07XG5cbiAgICAgIHBhcnNlclxuICAgICAgICAud3JpdGUoaW5wdXQpXG4gICAgICAgIC5jbG9zZSgpXG4gICAgICAgIC5mbHVzaCgpO1xuICAgIH0sXG4gICk7XG5cbmludGVyZmFjZSBPcGVuVGFnIHtcbiAgbmFtZTogc3RyaW5nO1xuICBhdHRyaWJ1dGVzOiB7fTtcbiAgaXNTZWxmQ2xvc2luZzogYm9vbGVhbjtcbn1cbiJdfQ==